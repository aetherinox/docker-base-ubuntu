#!/command/with-contenv bash
# shellcheck shell=bash

# #
#   @version        3
#   @file           docker-images.v3
#   @date           06-16-2025
#   @usage          makes use of s6-overlay for docker containers
#                   https://github.com/just-containers/s6-overlay
# #

# #
#   define > colors
#
#   Use the color table at:
#       - https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797
# #

declare -A c=(
    [end]=$'\e[0m'
    [white]=$'\e[97m'
    [bold]=$'\e[1m'
    [dim]=$'\e[2m'
    [underline]=$'\e[4m'
    [strike]=$'\e[9m'
    [blink]=$'\e[5m'
    [inverted]=$'\e[7m'
    [hidden]=$'\e[8m'
    [black]=$'\e[0;30m'
    [redl]=$'\e[0;91m'
    [redd]=$'\e[0;31m'
    [red1]=$'\e[38;5;160m'
    [red2]=$'\e[38;5;196m'
    [magental]=$'\e[0;95m'
    [magentad]=$'\e[0;35mm'
    [fuchsia1]=$'\e[38;5;205m'
    [fuchsia2]=$'\e[38;5;198m'
    [bluel]=$'\e[0;94m'
    [blued]=$'\e[0;34m'
    [blue1]=$'\e[38;5;033m'
    [blue2]=$'\e[38;5;033m'
    [blue3]=$'\e[38;5;68m'
    [cyanl]=$'\e[0;96m'
    [cyand]=$'\e[0;36m'
    [greenl]=$'\e[0;92m'
    [greend]=$'\e[0;32m'
    [green1]=$'\e[38;5;2m'
    [green2]=$'\e[38;5;76m'
    [yellowl]=$'\e[0;93m'
    [yellowd]=$'\e[0;33m'
    [yellow1]=$'\e[38;5;184m'
    [yellow2]=$'\e[38;5;190m'
    [yellow3]=$'\e[38;5;193m'
    [orange1]=$'\e[38;5;202m'
    [orange2]=$'\e[38;5;208m'
    [greyl]=$'\e[0;37m'
    [greyd]=$'\e[0;90m'
    [grey1]=$'\e[38;5;240m'
    [grey2]=$'\e[38;5;244m'
    [grey3]=$'\e[38;5;250m'
    [navy]=$'\e[38;5;62m'
    [olive]=$'\e[38;5;144m'
    [peach]=$'\e[38;5;210m'
)

# #
#   unicode for emojis
#       https://apps.timwhitlock.info/emoji/tables/unicode
# #

declare -A icon=(
    ["symbolic link"]=$'\xF0\x9F\x94\x97' # ğŸ”—
    ["regular file"]=$'\xF0\x9F\x93\x84' # ğŸ“„
    ["directory"]=$'\xF0\x9F\x93\x81' # ğŸ“
    ["regular empty file"]=$'\xe2\xad\x95' # â­•
    ["log"]=$'\xF0\x9F\x93\x9C' # ğŸ“œ
    ["1"]=$'\xF0\x9F\x93\x9C' # ğŸ“œ
    ["2"]=$'\xF0\x9F\x93\x9C' # ğŸ“œ
    ["3"]=$'\xF0\x9F\x93\x9C' # ğŸ“œ
    ["4"]=$'\xF0\x9F\x93\x9C' # ğŸ“œ
    ["5"]=$'\xF0\x9F\x93\x9C' # ğŸ“œ
    ["pem"]=$'\xF0\x9F\x94\x92' # ğŸ”‘
    ["pub"]=$'\xF0\x9F\x94\x91' # ğŸ”’
    ["pfx"]=$'\xF0\x9F\x94\x92' # ğŸ”‘
    ["p12"]=$'\xF0\x9F\x94\x92' # ğŸ”‘
    ["key"]=$'\xF0\x9F\x94\x91' # ğŸ”’
    ["crt"]=$'\xF0\x9F\xAA\xAA ' # ğŸªª
    ["gz"]=$'\xF0\x9F\x93\xA6' # ğŸ“¦
    ["zip"]=$'\xF0\x9F\x93\xA6' # ğŸ“¦
    ["gzip"]=$'\xF0\x9F\x93\xA6' # ğŸ“¦
    ["deb"]=$'\xF0\x9F\x93\xA6' # ğŸ“¦
    ["sh"]=$'\xF0\x9F\x97\x94' # ğŸ—”
)

# #
#   script version
# #

MOD_SCRIPT_VER='3.20241218'

# #
#   Custom folder paths
# #

SCRIPTS_DIR='/custom-cont-init.d'
SERVICES_DIR='/custom-services.d'

# #
#   Define output type
# #

if [[ ${DOCKER_MODS_DEBUG_CURL,,} = 'true' ]]; then
    CURL_NOISE_LEVEL='-v'
else
    CURL_NOISE_LEVEL='--silent'
fi

# #
#   Tamper check
# #

tamper_check()
{
    # Tamper check custom service locations
    if [[ -d "${SERVICES_DIR}" ]] && [[ -n "$(find ${SERVICES_DIR}/* ! -user root 2>/dev/null)" ]]; then
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                         â•‘
â•‘        Some of the contents of the folder ${SERVICES_DIR}            â•‘
â•‘            are not owned by root, which is a security risk.             â•‘
â•‘                                                                         â•‘
â•‘  Please review the permissions of this folder and its contents to make  â•‘
â•‘     sure they are owned by root, and can only be modified by root.      â•‘
â•‘                                                                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    elif [[ -d "${SERVICES_DIR}" ]] && [[ -n "$(find ${SERVICES_DIR}/* -perm -o+w 2>/dev/null)" ]]; then
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                         â•‘
â•‘        Some of the contents of the folder ${SERVICES_DIR}            â•‘
â•‘      have write permissions for others, which is a security risk.       â•‘
â•‘                                                                         â•‘
â•‘  Please review the permissions of this folder and its contents to make  â•‘
â•‘     sure they are owned by root, and can only be modified by root.      â•‘
â•‘                                                                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    fi

    # #
    #   Check custom script paths
    # #

    if [[ -d "${SCRIPTS_DIR}" ]] && [[ -n "$(find ${SCRIPTS_DIR}/* ! -user root 2>/dev/null)" ]]; then
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                         â•‘
â•‘        Some of the contents of the folder ${SCRIPTS_DIR}           â•‘
â•‘            are not owned by root, which is a security risk.             â•‘
â•‘                                                                         â•‘
â•‘  Please review the permissions of this folder and its contents to make  â•‘
â•‘     sure they are owned by root, and can only be modified by root.      â•‘
â•‘                                                                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    elif [[ -d "${SCRIPTS_DIR}" ]] && [[ -n "$(find ${SCRIPTS_DIR}/* -perm -o+w 2>/dev/null)" ]]; then
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                         â•‘
â•‘        Some of the contents of the folder ${SCRIPTS_DIR}           â•‘
â•‘      have write permissions for others, which is a security risk.       â•‘
â•‘                                                                         â•‘
â•‘  Please review the permissions of this folder and its contents to make  â•‘
â•‘     sure they are owned by root, and can only be modified by root.      â•‘
â•‘                                                                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    fi
}

# #
#   Custom Services
# #

process_custom_services()
{

    # #
    #   Remove all existing custom services before continuing to ensure
    #   we aren't running anything the user may have removed
    # #

    if [[ -n "$(/bin/ls -A /etc/s6-overlay/s6-rc.d/custom-svc-* 2>/dev/null)" ]]; then
        printf '%-29s %-65s\n' "  ${c[bluel]}Custom${c[end]}" "${c[end]}Removing existing custom services${c[end]}"
        rm -rf /etc/s6-overlay/s6-rc.d/custom-svc-*
        rm /etc/s6-overlay/s6-rc.d/user/contents.d/custom-svc-*
    fi

    # #
    #   Ensure custom service directory exists and has files in it
    # #

    if [[ -e "${SERVICES_DIR}" ]] && [[ -n "$(/bin/ls -A ${SERVICES_DIR} 2>/dev/null)" ]]; then

        printf '%-29s %-65s\n' "  ${c[bluel]}Custom${c[end]}" "${c[end]}Service files found in ${c[yellow2]} ${SERVICES_DIR} ${c[end]}"

        for SERVICE in "${SERVICES_DIR}"/*; do
            NAME="$(basename "${SERVICE}")"
            if [[ -f "${SERVICE}" ]]; then
                printf '%-29s %-65s\n' "  ${c[bluel]}Custom${c[end]}" "${c[end]}${c[bluel]}${NAME}${c[end]} detected, copying files${c[end]}"
                mkdir -p /etc/s6-overlay/s6-rc.d/custom-svc-"${NAME}"/dependencies.d/
                cp "${SERVICE}" /etc/s6-overlay/s6-rc.d/custom-svc-"${NAME}"/run
                chmod +x /etc/s6-overlay/s6-rc.d/custom-svc-"${NAME}"/run
                echo "longrun" >/etc/s6-overlay/s6-rc.d/custom-svc-"${NAME}"/type
                touch /etc/s6-overlay/s6-rc.d/custom-svc-"${NAME}"/dependencies.d/init-services
                touch /etc/s6-overlay/s6-rc.d/user/contents.d/custom-svc-"${NAME}"
                printf '%-29s %-65s\n' "  ${c[bluel]}Custom${c[end]}" "${c[end]}${c[bluel]}${NAME}${c[end]} copied${c[end]}"
            elif [[ ! -f "${SERVICE}" ]]; then
                printf '%-29s %-65s\n' "  ${c[bluel]}Custom${c[end]}" "${c[end]}${c[bluel]}${NAME}${c[end]} is not a valid service file, skipping ${c[end]}"
            fi
        done
    else
        printf '%-29s %-65s\n' "  ${c[bluel]}Custom${c[end]}" "${c[end]}No custom services detected, skipping ${c[end]}"
    fi
}

# #
#   Create with-contenv alias with umask support
# #

create_with_contenv_alias()
{
    if [[ ! -f /command/with-contenv ]]; then
        echo "/command/with-contenv not found, skipping alias creation"
        return
    fi
    rm -rf /usr/bin/with-contenv
    # intentional tabs in the heredoc
    cat <<-EOF >/usr/bin/with-contenv
	#!/bin/bash
	if [[ -f /run/s6/container_environment/UMASK ]] &&
	    { [[ "\$(pwdx \$\$)" =~ "/run/s6/legacy-services/" ]] ||
	        [[ "\$(pwdx \$\$)" =~ "/run/s6/services/" ]] ||
	        [[ "\$(pwdx \$\$)" =~ "/servicedirs/svc-" ]]; }; then
	    umask "\$(cat /run/s6/container_environment/UMASK)"
	fi
	exec /command/with-contenv "\$@"
	EOF
    chmod +x /usr/bin/with-contenv
}

# #
#   Check for curl
# #

curl_check()
{
    if [[ ! -f /usr/bin/curl ]] || [[ ! -f /usr/bin/jq ]]; then
        exec_info "Curl/JQ was not found on this system for Docker mods installing"
        if [[ -f /usr/bin/apt ]]; then
            # Ubuntu
            export DEBIAN_FRONTEND="noninteractive"
            apt-get update
            apt-get install --no-install-recommends -y \
                curl \
                jq
        elif [[ -f /sbin/apk ]]; then
            # Alpine
            apk add --no-cache \
                curl \
                jq
        elif [[ -f /usr/bin/dnf ]]; then
            # Fedora
            dnf install -y --setopt=install_weak_deps=False --best \
                curl \
                jq
        elif [[ -f /usr/sbin/pacman ]]; then
            # Arch
            pacman -Sy --noconfirm \
                curl \
                jq
        fi
    fi
}

# #
#   Define > Message Types
# #

exec_info()
{
    local MSG=$*
    echo "[mod-init] $MSG"
}

exec_err()
{
    local MSG=$*
    echo "[mod-init] (ERROR) $MSG"
}

exec_debug()
{
    local MSG=$*
    if [[ ${DOCKER_MODS_DEBUG,,} = "true" ]]; then echo "[mod-init] (DEBUG) $MSG"; fi
}

# #
#   Get > Global SHA
#
#   Use different filtering depending on the URL
# #

get_blob_sha()
{
    MULTIDIGEST=$(curl  -f --retry 10 --retry-max-time 60 --retry-connrefused \
        ${CURL_NOISE_LEVEL} \
        --location \
        --header "Accept: application/vnd.docker.distribution.manifest.v2+json" \
        --header "Accept: application/vnd.oci.image.index.v1+json" \
        --header "Authorization: Bearer ${1}" \
        --user-agent "${MOD_UA}" \
        "${2}/${3}")

    if jq -e '.layers // empty' <<< "${MULTIDIGEST}" >/dev/null 2>&1; then
        # If there's a layer element it's a single-arch manifest so just get that digest
        jq -r '.layers[0].digest' <<< "${MULTIDIGEST}";
    else
        # #
        #   multi-arch or has manifest annotations
        # #

        if jq -e '.manifests[]?.annotations // empty' <<< "${MULTIDIGEST}" >/dev/null 2>&1; then
            # Check for manifest annotations and delete if found
            exec_debug "Mod has one or more manifest annotations" >&2
            MULTIDIGEST=$(jq 'del(.manifests[] | select(.annotations))' <<< "${MULTIDIGEST}")
        fi

        if [[ $(jq '.manifests | length' <<< "${MULTIDIGEST}") -gt 1 ]]; then
            # If there's still more than one digest, it's multi-arch
            exec_debug "Mod has multi-arch manifest" >&2
            MULTIDIGEST=$(jq -r ".manifests[] | select(.platform.architecture == \"${4}\").digest?" <<< "${MULTIDIGEST}")
            if [[ -z "${MULTIDIGEST}" ]]; then
                exit 1
            fi
        else
            # #
            #   Single arch
            # #

            exec_debug "Mod has a single arch manifest" >&2
            MULTIDIGEST=$(jq -r ".manifests[].digest?" <<< "${MULTIDIGEST}")
        fi

        if DIGEST=$(curl  -f --retry 10 --retry-max-time 60 --retry-connrefused \
            ${CURL_NOISE_LEVEL} \
            --location \
            --header "Accept: application/vnd.docker.distribution.manifest.v2+json" \
            --header "Accept: application/vnd.oci.image.manifest.v1+json" \
            --header "Authorization: Bearer ${1}" \
            --user-agent "${MOD_UA}" \
            "${2}/${MULTIDIGEST}"); then
            jq -r '.layers[0].digest' <<< "${DIGEST}";
        fi
    fi
}

# #
#   Get > Auth URL
# #

get_auth_url()
{
    local auth_header
    local realm_url
    local service
    local scope

    # #
    #   Get manifests and extract www-authenticate header
    # #

    auth_header=$(curl -sLI ${CURL_NOISE_LEVEL} "${1}/${2}" | grep -i www-authenticate | tr -d '\r')
    if [[ -n "${auth_header}" ]]; then
        exec_debug "${auth_header}" >&2

        # #
        #   Extract realm URL from www-authenticate header
        # #

        realm_url=$(echo "$auth_header" | awk -F'[="]+' '/realm=/{print $2}')
        service=$(echo "$auth_header" | awk -F'[="]+' '/service=/{print $4}')
        scope=$(echo "$auth_header" | awk -F'[="]+' '/scope=/{print $6}')
        echo "$realm_url?service=$service&scope=$scope"
    else
        exit 1
    fi
}

# #
#   Get > Architecture
# #

get_arch()
{
    local arch

    if [[ -f /sbin/apk ]]; then
        arch=$(apk --print-arch)
    elif [[ -f /usr/bin/dpkg ]]; then
        arch=$(dpkg --print-architecture)
    else
        arch=$(uname -m)
    fi

    case "${arch}" in
    x86_64 )
        arch="amd64"
        ;;
    aarch64 )
        arch="arm64"
        ;;
    esac

    echo "${arch}"
}

# #
#   Run > main
# #

runtime()
{
    exec_info "Running Docker Modification Logic"
    exec_debug "Running in debug mode"
    exec_debug "Mod script version ${MOD_SCRIPT_VER}"

    for DOCKER_MOD in $(echo "${DOCKER_MODS}" | tr '|' '\n'); do

        # #
        #   Support alternative endpoints
        # #

        case "${DOCKER_MOD}" in
        aetherinox/* )
            [[ ${DOCKER_MODS_FORCE_REGISTRY,,} = "true" ]] && REGISTRY="registry-1.docker.io" || REGISTRY="lscr.io"
            ;;
        docker.io/aetherinox/* )
            [[ ${DOCKER_MODS_FORCE_REGISTRY,,} = "true" ]] && REGISTRY="registry-1.docker.io" || REGISTRY="lscr.io"
            DOCKER_MOD="${DOCKER_MOD#docker.io/*}"
            ;;
        ghcr.io/aetherinox/* )
            [[ ${DOCKER_MODS_FORCE_REGISTRY,,} = "true" ]] && REGISTRY="ghcr.io" || REGISTRY="lscr.io"
            DOCKER_MOD="${DOCKER_MOD#ghcr.io/*}"
            ;;
        docker.io/* )
            REGISTRY="registry-1.docker.io"
            DOCKER_MOD="${DOCKER_MOD#docker.io/*}"
            ;;
        * )

            # #
            #   Default is docker.io
            # #

            REGISTRY="registry-1.docker.io"
            MOD="${DOCKER_MOD%/*}"

            # #
            #   If mod still has a forward slash / after stripping off the image name; it isnt docker.io
            # #

            if [[ $MOD == */* ]]; then
                REGISTRY="${MOD%%/*}"
                DOCKER_MOD="${DOCKER_MOD#"$REGISTRY"/*}"

            # #
            #   If repo name has . in it, assume it's a registry with no repo
            # #

            elif [[ ${DOCKER_MOD%%/*} =~ \. ]]; then
                REGISTRY="${DOCKER_MOD%%/*}"
                MOD="${DOCKER_MOD##*/}"
            fi
            ;;
        esac

        ENDPOINT="${DOCKER_MOD%%:*}"
        USERNAME="${DOCKER_MOD%%/*}"
        REPO="${ENDPOINT#*/}"
        TAG="${DOCKER_MOD#*:}"

        if [[ "${TAG}" == "${DOCKER_MOD}" ]]; then
            TAG="latest"
        fi

        FILENAME="${USERNAME}.${REPO}.${TAG}"
        MANIFEST_URL="https://${REGISTRY}/v2/${ENDPOINT}/manifests"
        BLOB_URL="https://${REGISTRY}/v2/${ENDPOINT}/blobs/"
        MOD_UA="Mozilla/5.0 (Linux $(uname -m)) Aetherinox ${REGISTRY}/${ENDPOINT}:${TAG}"
        exec_debug "Registry='${REGISTRY}', Repository='${USERNAME}', Image='${ENDPOINT}', Tag='${TAG}'"

        case "${REGISTRY}" in
            "lscr.io") AUTH_URL="https://ghcr.io/token?scope=repository%3A${USERNAME}%2F${REPO}%3Apull";;
            "ghcr.io") AUTH_URL="https://ghcr.io/token?scope=repository%3A${USERNAME}%2F${REPO}%3Apull";;
            "quay.io") AUTH_URL="https://quay.io/v2/auth?service=quay.io&scope=repository%3A${USERNAME}%2F${REPO}%3Apull";;
            "registry-1.docker.io") AUTH_URL="https://auth.docker.io/token?service=registry.docker.io&scope=repository:${ENDPOINT}:pull";;
            *) AUTH_URL=$(get_auth_url "${MANIFEST_URL}" "${TAG}")
        esac

        # #
        #   Halt mods logic if any of the usernames are banned
        # #

        for BANNED in $(curl -s https://raw.githubusercontent.com/aetherinox/docker-base-alpine/docker/core/blacklist.txt); do
            if [[ "${BANNED,,}" == "${USERNAME,,}" ]]; then
                if [[ -z ${RUN_BANNED_MODS+x} ]]; then
                    exec_info "${DOCKER_MOD} is banned from use due to reported abuse, skipping mod"
                    continue
                else
                    exec_info "You have chosen to run banned mods, ${DOCKER_MOD} will be applied"
                fi
            fi
        done

        if [[ -n "${AUTH_URL}" ]]; then

            # #
            #   Get registry token for api operations
            # #

            TOKEN="$(
                curl -f --retry 10 --retry-max-time 60 --retry-connrefused \
                    ${CURL_NOISE_LEVEL} \
                    "${AUTH_URL}" |
                    jq -r '.token'
            )"
        else
            exec_info "Could not fetch auth URL from registry for ${DOCKER_MOD}, attempting unauthenticated fetch"
        fi

        exec_info "Adding ${DOCKER_MOD} to container"

        # #
        #   If we're using lscr try and get the manifest from ghcr, if it fails re-request a token from Docker Hub
        # #

        if [[ "${REGISTRY}" == "lscr.io" ]]; then
            if [[ -n $(curl --user-agent "${MOD_UA}" -sLH "Authorization: Bearer ${TOKEN}" "${MANIFEST_URL}/${TAG}" | jq -r '.errors' >/dev/null 2>&1) ]]; then
                exec_debug "Couldn't fetch manifest from ghcr.io, trying docker.io"
                AUTH_URL="https://auth.docker.io/token?service=registry.docker.io&scope=repository:${ENDPOINT}:pull"
                TOKEN="$(
                    curl -f --retry 10 --retry-max-time 60 --retry-connrefused \
                        ${CURL_NOISE_LEVEL} \
                        "${AUTH_URL}" |
                        jq -r '.token'
                )"
            fi
        fi

        if [[ -n "${AUTH_URL}" ]]; then
            exec_debug "Using ${AUTH_URL} as auth endpoint"
        fi

        ARCH=$(get_arch)
        exec_debug "Arch detected as ${ARCH}"

        # #
        #   Determine first and only layer of image
        # #

        SHALAYER=$(get_blob_sha "${TOKEN}" "${MANIFEST_URL}" "${TAG}" "${ARCH:=-amd64}")

        if [[ $? -eq 1 ]]; then
            exec_err "No manifest available for arch ${ARCH:=-amd64}, cannot fetch mod"
            continue
        elif [[ -z "${SHALAYER}" ]]; then
            exec_err "${DOCKER_MOD} digest could not be fetched from ${REGISTRY}"
            continue
        fi

        # #
        #   Check if we have allready applied this layer
        # #

        if [[ -f "/${FILENAME}" ]] && [[ "${SHALAYER}" == "$(cat /"${FILENAME}")" ]]; then
            exec_info "${DOCKER_MOD} at ${SHALAYER} has been previously applied skipping"
        else
            exec_info "Downloading ${DOCKER_MOD} from ${REGISTRY}"

            # #
            #   Download and extract layer to /
            # #

            curl -f --retry 10 --retry-max-time 60 --retry-all-errors \
                ${CURL_NOISE_LEVEL} \
                --location \
                --header "Authorization: Bearer ${TOKEN}" \
                --user-agent "${MOD_UA}" \
                "${BLOB_URL}${SHALAYER}" -o \
                "/${FILENAME}.tar.xz"
            mkdir -p /tmp/mod

            if ! tar -tzf "/${FILENAME}.tar.xz" >/dev/null 2>&1; then
                exec_err "Invalid tarball, could not download ${DOCKER_MOD} from ${REGISTRY}"
                continue
            fi

            exec_info "Installing ${DOCKER_MOD}"
            tar xzf "/${FILENAME}.tar.xz" -C /tmp/mod

            # #
            #   Remove any v2 mod elements as they're no longer supported
            # #

            if [[ -d /tmp/mod/etc/cont-init.d ]]; then
                rm -rf /tmp/mod/etc/cont-init.d
            fi

            if [[ -d /tmp/mod/etc/services.d ]]; then
                rm -rf /tmp/mod/etc/services.d
            fi

            shopt -s dotglob
            cp -R /tmp/mod/* /
            shopt -u dotglob
            rm -rf /tmp/mod
            rm -rf "/${FILENAME}.tar.xz"
            echo "${SHALAYER}" >"/${FILENAME}"
            exec_info "${DOCKER_MOD} applied to container"
        fi
    done
}

# #
#   run > local
# #

runtime_local()
{
    exec_info "Running Local Docker Modification Logic"
    for DOCKER_MOD in $(echo "${DOCKER_MODS}" | tr '|' '\n'); do

        # #
        #   Check mod file exists
        # #

        if [[ -f "/mods/${DOCKER_MOD}.tar" ]]; then
            # #
            #   Calculate mod bits
            # #

            FILENAME="${DOCKER_MOD}.local"
            SHALAYER=$(sha256sum "/mods/${DOCKER_MOD}.tar" | cut -d " " -f 1)
            exec_debug "Mod checksum is ${SHALAYER}"

            # #
            #   Check if we have allready applied this layer
            # #

            if [[ -f "/${FILENAME}" ]] && [[ "${SHALAYER}" == "$(cat /"${FILENAME}")" ]]; then
                exec_info "${DOCKER_MOD} at ${SHALAYER} has been previously applied, skipping"
            else
                exec_info "Installing ${DOCKER_MOD} from /mods/${DOCKER_MOD}.tar"
                mkdir -p "/tmp/mod/${DOCKER_MOD}"
                tar xf "/mods/${DOCKER_MOD}.tar" -C "/tmp/mod/${DOCKER_MOD}"

                # #
                #   Remove any v2 mod elements as they're no longer supported
                # #

                if [[ -d "/tmp/mod/${DOCKER_MOD}/etc/cont-init.d" ]]; then
                    rm -rf "/tmp/mod/${DOCKER_MOD}/etc/cont-init.d"
                fi

                if [[ -d "/tmp/mod/${DOCKER_MOD}/etc/services.d" ]]; then
                    rm -rf "/tmp/mod/${DOCKER_MOD}/etc/services.d"
                fi

                shopt -s dotglob
                cp -R "/tmp/mod/${DOCKER_MOD}"/* /
                shopt -u dotglob
                rm -rf "/tmp/mod/${DOCKER_MOD}"
                echo "${SHALAYER}" >"/${FILENAME}"
                exec_info "${DOCKER_MOD} applied to container"
            fi
        elif [[ -d "/mods/${DOCKER_MOD}" ]]; then

            # #
            #   Calculate mod bits
            # #

            FILENAME="${DOCKER_MOD}.local"
            SHALAYER=$(tar c "/mods/${DOCKER_MOD}"  2>/dev/null | sha256sum | cut -d " " -f 1)
            exec_debug "Mod checksum is ${SHALAYER}"

            # #
            #   Check if we have allready applied this layer
            # #

            if [[ -f "/${FILENAME}" ]] && [[ "${SHALAYER}" == "$(cat /"${FILENAME}")" ]]; then
                exec_info "${DOCKER_MOD} at ${SHALAYER} has been previously applied, skipping"
            else
                exec_info "Installing ${DOCKER_MOD} from /mods/${DOCKER_MOD}/"
                mkdir -p "/tmp/mod/${DOCKER_MOD}"
                cp -R "/mods/${DOCKER_MOD}" "/tmp/mod/"

                # #
                #   Remove any v2 mod elements as they're no longer supported
                # #

                if [[ -d "/tmp/mod/${DOCKER_MOD}/etc/cont-init.d" ]]; then
                    rm -rf "/tmp/mod/${DOCKER_MOD}/etc/cont-init.d"
                fi

                if [[ -d "/tmp/mod/${DOCKER_MOD}/etc/services.d" ]]; then
                    rm -rf "/tmp/mod/${DOCKER_MOD}/etc/services.d"
                fi

                shopt -s dotglob
                cp -R "/tmp/mod/${DOCKER_MOD}"/* /
                shopt -u dotglob
                rm -rf "/tmp/mod/${DOCKER_MOD}"
                echo "${SHALAYER}" >"/${FILENAME}"
                exec_info "${DOCKER_MOD} applied to container"
            fi
        else
            exec_err "${DOCKER_MOD} not found in /mods, skipping"
        fi
    done
}

# #
#   Run > branding
# #

run_branding()
{
  cat <<-EOF | tee /run/branding /etc/s6-overlay/s6-rc.d/init-adduser/branding > /dev/null 2>&1
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                             Linux Alpine - Base Image
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
	EOF
}

# #
#   Main Script
# #

if grep -qEe ' / \w+ ro' /proc/mounts; then
    printf '1' > /run/s6/container_environment/AETHERX_READ_ONLY_FS
    AETHERX_READ_ONLY_FS=1
fi

if [[ ! $(stat /run -c %u) == "0" ]]; then
    printf '1' > /run/s6/container_environment/AETHERX_NON_ROOT_USER
    AETHERX_NON_ROOT_USER=1
fi

if [[ "${AETHERX_FIRST_PARTY}" = "true" ]]; then
    run_branding
fi

if [[ -z ${AETHERX_READ_ONLY_FS} ]] && [[ -z ${AETHERX_NON_ROOT_USER} ]]; then
    # Run alias creation functions
    if [[ ! -f "/usr/bin/with-contenv" ]] || [[ -L "/usr/bin/with-contenv" ]]; then
        create_with_contenv_alias
    fi

    if [[ -d "${SCRIPTS_DIR}" ]] || [[ -d "${SERVICES_DIR}" ]]; then
        tamper_check
        process_custom_services
    fi

    # Run mod logic
    if [[ -n "${DOCKER_MODS+x}" ]] && [[ "${DOCKER_MODS_SIDELOAD,,}" = "true" ]]; then
        runtime_local
    elif [[ -n "${DOCKER_MODS+x}" ]]; then
        curl_check
        runtime
    fi
elif [[ -n ${AETHERX_READ_ONLY_FS} ]] && [[ -n ${AETHERX_NON_ROOT_USER} ]]; then
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                         â•‘
â•‘    You are running this container read-only and as a non-root user:     â•‘
â•‘              This combination of settings is not supported              â•‘
â•‘                  and may result in unwanted behaviour.                  â•‘
â•‘                                                                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
elif [[ -n ${AETHERX_READ_ONLY_FS} ]]; then
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                         â•‘
â•‘                You are running this container read-only:                â•‘
â•‘   UMASK, custom services, & docker mod functionality will be disabled   â•‘
â•‘      and the PUID/PGID environment variables will have no effect.       â•‘
â•‘                                                                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
elif [[ -n ${AETHERX_NON_ROOT_USER} ]]; then
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                         â•‘
â•‘           You are running this container as a non-root user:            â•‘
â•‘   UMASK, custom services, & docker mod functionality will be disabled   â•‘
â•‘      and the PUID/PGID environment variables will have no effect.       â•‘
â•‘                                                                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
fi
